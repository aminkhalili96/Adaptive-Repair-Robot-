"""
Agent tools for the LangGraph workflow.

Tools available to the agent:
- detect_defects: Trigger vision pipeline
- classify_defect: Analyze defect severity
- plan_repair: Generate repair strategy
- execute_repair: Execute the repair path
- verify_repair: Re-scan to verify success
"""

import json
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

from src.config import config


@dataclass
class DefectInfo:
    """Information about a detected defect for the agent."""
    index: int
    type: str
    position: tuple
    size: float
    confidence: float
    
    def to_prompt_string(self) -> str:
        """Format for LLM prompt."""
        return f"[{self.index}] {self.type.upper()}: pos=({self.position[0]:.2f}, {self.position[1]:.2f}, {self.position[2]:.2f}), size={self.size:.1f}cmÂ², conf={self.confidence:.0%}"


@dataclass
class RepairPlan:
    """Repair plan generated by the agent."""
    defect_index: int
    defect_type: str
    severity: str
    strategy: str
    tool: str
    estimated_time: int
    notes: str
    
    def to_dict(self) -> Dict:
        return {
            "defect_index": self.defect_index,
            "defect_type": self.defect_type,
            "severity": self.severity,
            "strategy": self.strategy,
            "tool": self.tool,
            "estimated_time": self.estimated_time,
            "notes": self.notes,
        }


# Fallback strategies when LLM fails (per Codex feedback)
FALLBACK_STRATEGIES = {
    "rust": {
        "severity": "moderate",
        "strategy": "spiral",
        "tool": "sanding_disc_80",
        "estimated_time_seconds": 30,
        "notes": "Fallback: standard rust treatment"
    },
    "crack": {
        "severity": "moderate",
        "strategy": "raster",
        "tool": "filler_applicator",
        "estimated_time_seconds": 45,
        "notes": "Fallback: standard crack filling"
    },
    "dent": {
        "severity": "moderate",
        "strategy": "circular",
        "tool": "body_hammer",
        "estimated_time_seconds": 60,
        "notes": "Fallback: standard dent removal"
    },
    "unknown": {
        "severity": "minor",
        "strategy": "spiral",
        "tool": "inspection_only",
        "estimated_time_seconds": 15,
        "notes": "Fallback: unknown defect, inspection only"
    },
}


def get_fallback_plan(defect_type: str) -> Dict:
    """
    Get fallback repair plan when LLM fails.
    
    Args:
        defect_type: Type of defect
        
    Returns:
        Fallback plan dictionary
    """
    return FALLBACK_STRATEGIES.get(
        defect_type.lower(),
        FALLBACK_STRATEGIES["unknown"]
    )


def parse_llm_response(response: str) -> Optional[Dict]:
    """
    Parse JSON from LLM response.
    
    Args:
        response: LLM response string
        
    Returns:
        Parsed dictionary or None if parsing fails
    """
    try:
        # Try to extract JSON from response
        # Handle cases where LLM adds extra text
        response = response.strip()
        
        # Find JSON in response
        start = response.find('{')
        end = response.rfind('}') + 1
        
        if start >= 0 and end > start:
            json_str = response[start:end]
            return json.loads(json_str)
        
        return None
    except json.JSONDecodeError:
        return None


def validate_repair_plan(plan: Dict) -> bool:
    """
    Validate a repair plan from the LLM.
    
    Args:
        plan: Repair plan dictionary
        
    Returns:
        True if valid, False otherwise
    """
    required_fields = ["severity", "strategy", "tool", "estimated_time_seconds"]
    
    # Check required fields
    for field in required_fields:
        if field not in plan:
            return False
    
    # Validate severity
    if plan["severity"] not in ["minor", "moderate", "severe"]:
        return False
    
    # Validate strategy
    if plan["strategy"] not in ["spiral", "raster", "circular"]:
        return False
    
    # Validate time
    if not isinstance(plan.get("estimated_time_seconds"), (int, float)):
        return False
    if plan["estimated_time_seconds"] <= 0 or plan["estimated_time_seconds"] > 300:
        return False
    
    return True
